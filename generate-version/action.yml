name: "ğŸ”¢ Generate Version"
description: "Generates semantic version numbers based on Git tags and branch information"
author: "Francois Raminosona"

inputs:
  config-file:
    description: 'Path to version.json file. Format : { "major": 1, "minor": 0 }'
    required: false
  major:
    description: "Major version number"
    required: false
  minor:
    description: "Minor version number"
    required: false
  main-branch:
    description: "Name of the main branch"
    required: false
    default: ${{ github.event.repository.default_branch }}
  build-id:
    description: "Build ID for revision numbering (defaults to GitHub run number)"
    required: false
    default: ${{ github.run_number }}
  tag-prefix:
    description: "Prefix for version tags (e.g., 'v' for 'v1.0.0')"
    required: false
    default: "v"
  branch-suffix-max-length:
    description: "Maximum length for branch name suffix"
    required: false
    default: "40"
  output-txt:
    description: "Path to output txt file with key=value pairs"
    required: false
    default: ""
  output-props:
    description: "Path to output .NET props file"
    required: false
    default: ""
  output-json:
    description: "Path to output JSON file with version information"
    required: false
    default: ""
  fetch-depth:
    description: "Depth of Git history to fetch for tag analysis"
    required: false
    default: "0"
  show-summary:
    description: "Whether to show the action summary"
    required: false
    default: "false"
  dry-run:
    description: "Run in dry-run mode (generate versions but don't create output files)"
    required: false
    default: "false"

outputs:
  VERSION_MAJOR:
    description: "Major version number"
    value: ${{ steps.generate.outputs.VERSION_MAJOR }}
  VERSION_MINOR:
    description: "Minor version number"
    value: ${{ steps.generate.outputs.VERSION_MINOR }}
  VERSION_PATCH:
    description: "Patch version number"
    value: ${{ steps.generate.outputs.VERSION_PATCH }}
  VERSION_SUFFIX:
    description: "Version suffix (branch name for non-main branches)"
    value: ${{ steps.generate.outputs.VERSION_SUFFIX }}
  VERSION_REVISION:
    description: "Revision number (build ID for non-main branches)"
    value: ${{ steps.generate.outputs.VERSION_REVISION }}
  VERSION_ISPRERELEASE:
    description: "Whether this is a prerelease version (true for non-main branches)"
    value: ${{ steps.generate.outputs.VERSION_ISPRERELEASE }}
  VERSION_BUILDID:
    description: "Build ID used for versioning"
    value: ${{ steps.generate.outputs.VERSION_BUILDID }}
  VERSION_CORE:
    description: "Core version (major.minor.patch)"
    value: ${{ steps.generate.outputs.VERSION_CORE }}
  VERSION_EXTENSION:
    description: "Version extension (suffix.revision for branches)"
    value: ${{ steps.generate.outputs.VERSION_EXTENSION }}
  VERSION_FULL:
    description: "Full version (core + extension)"
    value: ${{ steps.generate.outputs.VERSION_FULL }}
  VERSION_ASSEMBLY:
    description: "Assembly version for .NET (major.minor.patch.buildid)"
    value: ${{ steps.generate.outputs.VERSION_ASSEMBLY }}
  VERSION_FORTAG:
    description: "Version string suitable for Git tags (with prefix)"
    value: ${{ steps.generate.outputs.VERSION_PREFIX }}${{ steps.generate.outputs.VERSION_FULL }}
  VERSION_BRANCHNAME:
    description: "Current branch name"
    value: ${{ steps.generate.outputs.VERSION_BRANCHNAME }}
  VERSION_PREFIX:
    description: "Tag prefix used for version tags"
    value: ${{ steps.generate.outputs.VERSION_PREFIX }}
  VERSION_OUTPUTTXT:
    description: "Path to generated txt file (if created)"
    value: ${{ steps.generate.outputs.VERSION_OUTPUTTXT }}
  VERSION_OUTPUTPROPS:
    description: "Path to generated props file (if created)"
    value: ${{ steps.generate.outputs.VERSION_OUTPUTPROPS }}
  VERSION_OUTPUTJSON:
    description: "Path to generated JSON file (if created)"
    value: ${{ steps.generate.outputs.VERSION_OUTPUTJSON }}
  VERSION_TAG_EXISTS:
    description: "Whether a tag already exists for this version"
    value: ${{ steps.generate.outputs.VERSION_TAG_EXISTS }}
  VERSION_LATEST_TAG:
    description: "Latest tag found for this major.minor combination"
    value: ${{ steps.generate.outputs.VERSION_LATEST_TAG }}

runs:
  using: "composite"
  steps:
    # ================== â„¹ï¸ ==================
    - name: "â„¹ï¸ Gather environment information"
      shell: bash
      run: |
        echo "::group::â„¹ï¸ Environment Information"
        echo "::debug::Operating System: $(uname -a)"
        echo "::debug::GitHub Runner OS: $RUNNER_OS"
        echo "::debug::GitHub Runner Version: $RUNNER_VERSION"
        echo "::debug::Git Version: $(git --version || echo 'Not installed')"
        echo "::debug::jq Version: $(jq --version || echo 'Not installed')"
        echo "::endgroup::"

    # ================== ğŸ”’ ==================
    - name: "ğŸ”’ Mask sensitive data"
      shell: bash
      run: |
        # No sensitive inputs to mask in this action
        echo "âœ… No sensitive data to mask"

    # ================== ğŸ“ ==================
    - name: "ğŸ“ Normalize config-file path"
      id: normalize-config-file
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.config-file }}

    - name: "ğŸ“ Normalize output-txt path"
      id: normalize-output-txt
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.output-txt }}

    - name: "ğŸ“ Normalize output-props path"
      id: normalize-output-props
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.output-props }}

    - name: "ğŸ“ Normalize output-json path"
      id: normalize-output-json
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.output-json }}

    # ================== âœ… ==================

    - name: "âœ… Validate input : version numbers"
      shell: bash
      id: major-minor-validation
      run: |
        echo "::debug::Validating version number inputs..."

        if [ "${{ inputs.config-file }}" != "" ]; then
          echo "::debug::ğŸ“‹ Config file provided (${{ steps.normalize-config-file.outputs.normalized }})"

          if [ ! -f "${{ steps.normalize-config-file.outputs.normalized }}" ]; then
            echo "::error::Version configuration file ${{ steps.normalize-config-file.outputs.normalized }} not found"
            exit 1
          fi

          VERSION_MAJOR=$(jq -r '.major' "${{ steps.normalize-config-file.outputs.normalized }}")
          VERSION_MINOR=$(jq -r '.minor' "${{ steps.normalize-config-file.outputs.normalized }}")
        elif [ "${{ inputs.major }}" != "" ] && [ "${{ inputs.minor }}" != "" ]; then
          VERSION_MAJOR="${{ inputs.major }}"
          VERSION_MINOR="${{ inputs.minor }}"
        else
          echo "::error::You must provide either a config-file or both major and minor version numbers."
          exit 1
        fi

        # Validate major version
        if ! [[ "$VERSION_MAJOR" =~ ^[0-9]+$ ]]; then
          echo "::error::Major version must be a non-negative integer, got: $VERSION_MAJOR"
          exit 1
        fi

        # Validate minor version
        if ! [[ "$VERSION_MINOR" =~ ^[0-9]+$ ]]; then
          echo "::error::Minor version must be a non-negative integer, got: $VERSION_MINOR"
          exit 1
        fi

        echo "major=$VERSION_MAJOR" >> $GITHUB_OUTPUT
        echo "minor=$VERSION_MINOR" >> $GITHUB_OUTPUT

        echo "âœ… Version number validation completed successfully"

    - name: "âœ… Validate input : build ID"
      shell: bash
      run: |
        echo "::debug::Validating build ID input..."

        BUILD_ID="${{ inputs.build-id }}"

        if [ -z "$BUILD_ID" ]; then
          BUILD_ID="${{ github.run_number }}"
          echo "::debug::No build ID provided, using GitHub run number: $BUILD_ID"
        fi

        if ! [[ "$BUILD_ID" =~ ^[0-9]+$ ]]; then
          echo "::error::Build ID must be a non-negative integer, got: $BUILD_ID"
          exit 1
        fi

        echo "âœ… Build ID validation completed successfully"

    - name: "âœ… Validate input : numeric parameters"
      shell: bash
      run: |
        echo "::debug::Validating numeric parameter inputs..."

        # Validate fetch-depth
        if ! [[ "${{ inputs.fetch-depth }}" =~ ^[0-9]+$ ]]; then
          echo "::error::Fetch depth must be a non-negative integer, got: ${{ inputs.fetch-depth }}"
          exit 1
        fi

        # Validate branch-suffix-max-length
        if ! [[ "${{ inputs.branch-suffix-max-length }}" =~ ^[0-9]+$ ]] || [ "${{ inputs.branch-suffix-max-length }}" -eq 0 ]; then
          echo "::error::Branch suffix max length must be a positive integer, got: ${{ inputs.branch-suffix-max-length }}"
          exit 1
        fi

        echo "âœ… Numeric parameter validation completed successfully"

    - name: "âœ… Validate input : booleans"
      shell: bash
      run: |
        echo "::debug::Validating boolean inputs..."
        for param in show-summary dry-run; do
          case $param in
            show-summary) value="${{ inputs.show-summary }}" ;;
            dry-run) value="${{ inputs.dry-run }}" ;;
          esac
          if [ -n "$value" ] && [ "$value" != "true" ] && [ "$value" != "false" ]; then
            echo "::error::Parameter $param must be 'true' or 'false', got: $value"
            exit 1
          fi
        done

        echo "âœ… Boolean inputs validation completed successfully"

    - name: "âœ… Validate input : tag-prefix"
      shell: bash
      run: |
        echo "::debug::Validating tag-prefix input: ${{ inputs.tag-prefix }}"

        # Tag prefix should be safe for Git tags (no spaces, special chars)
        if [[ "${{ inputs.tag-prefix }}" =~ [[:space:]] ]] || [[ "${{ inputs.tag-prefix }}" =~ [\"\'] ]] || [[ "${{ inputs.tag-prefix }}" =~ [\\] ]]; then
          echo "::error::Tag prefix cannot contain spaces, quotes, or backslashes: ${{ inputs.tag-prefix }}"
          exit 1
        fi

        echo "âœ… Tag prefix validation completed successfully"

    - name: "âœ… Validate input : main-branch"
      if: ${{ inputs.main-branch != '' }}
      shell: bash
      run: |
        echo "::debug::Validating main-branch input: ${{ inputs.main-branch }}"

        # Main branch name should be a valid Git branch name
        if [[ "${{ inputs.main-branch }}" =~ [[:space:]] ]] || [[ "${{ inputs.main-branch }}" =~ \.\. ]] || [[ "${{ inputs.main-branch }}" =~ ^[\-\.] ]] || [[ "${{ inputs.main-branch }}" =~ [\-\.]$ ]]; then
          echo "::error::Invalid main branch name format: ${{ inputs.main-branch }}"
          exit 1
        fi

        echo "âœ… Main branch validation completed successfully"

    - name: "âœ… Validate input : output-txt"
      if: ${{ inputs.output-txt != '' }}
      shell: bash
      run: |
        echo "::debug::Validating output-txt input: ${{ steps.normalize-output-txt.outputs.normalized }}"

        # Validate file extension
        if [[ ! "${{ steps.normalize-output-txt.outputs.normalized }}" =~ \.(txt|env)$ ]]; then
          echo "::warning::Output txt file should typically have .txt or .env extension"
        fi

        # Validate output directory exists or can be created
        OUTPUT_DIR=$(dirname "${{ steps.normalize-output-txt.outputs.normalized }}")
        if [ "$OUTPUT_DIR" != "." ] && [ ! -d "$OUTPUT_DIR" ]; then
          echo "::debug::Output directory will be created: $OUTPUT_DIR"
        fi

        echo "âœ… Output txt validation completed successfully"

    - name: "âœ… Validate input : output-props"
      if: ${{ inputs.output-props != '' }}
      shell: bash
      run: |
        echo "::debug::Validating output-props input: ${{ steps.normalize-output-props.outputs.normalized }}"

        # Validate file extension
        if [[ ! "${{ steps.normalize-output-props.outputs.normalized }}" =~ \.(props|xml)$ ]]; then
          echo "::warning::Output props file should typically have .props or .xml extension"
        fi

        # Validate output directory exists or can be created
        OUTPUT_DIR=$(dirname "${{ steps.normalize-output-props.outputs.normalized }}")
        if [ "$OUTPUT_DIR" != "." ] && [ ! -d "$OUTPUT_DIR" ]; then
          echo "::debug::Output directory will be created: $OUTPUT_DIR"
        fi

        echo "âœ… Output props validation completed successfully"

    - name: "âœ… Validate input : output-json"
      if: ${{ inputs.output-json != '' }}
      shell: bash
      run: |
        echo "::debug::Validating output-json input: ${{ steps.normalize-output-json.outputs.normalized }}"

        # Validate file extension
        if [[ ! "${{ steps.normalize-output-json.outputs.normalized }}" =~ \.json$ ]]; then
          echo "::warning::Output JSON file should have .json extension"
        fi

        # Validate output directory exists or can be created
        OUTPUT_DIR=$(dirname "${{ steps.normalize-output-json.outputs.normalized }}")
        if [ "$OUTPUT_DIR" != "." ] && [ ! -d "$OUTPUT_DIR" ]; then
          echo "::debug::Output directory will be created: $OUTPUT_DIR"
        fi

        echo "âœ… Output JSON validation completed successfully"

    # ================== ğŸ” ==================
    - name: "ğŸ” Fetch Git history"
      shell: bash
      run: |
        echo "::debug::Fetching Git history for tag analysis and version calculation"

        # Verify we're in a Git repository
        if ! git rev-parse --git-dir >/dev/null 2>&1; then
          echo "::error::Not in a Git repository"
          exit 1
        fi

        # Fetch full history if fetch-depth is 0, otherwise fetch specified depth
        if [ "${{ inputs.fetch-depth }}" = "0" ]; then
          echo "::debug::Fetching full Git history"
          if git rev-parse --is-shallow-repository | grep -q true; then
            git fetch --unshallow --tags || {
              echo "::warning::Failed to unshallow repository, falling back to tag fetch"
              git fetch --tags
            }
          else
            git fetch --tags
          fi
        else
          echo "::debug::Fetching Git history with depth ${{ inputs.fetch-depth }}"
          git fetch --depth=${{ inputs.fetch-depth }} --tags
        fi

        # Verify we have access to tags
        TAG_COUNT=$(git tag -l | wc -l)
        echo "âœ… Found $TAG_COUNT existing tags"

        # Verify current branch information
        if git rev-parse --abbrev-ref HEAD >/dev/null 2>&1; then
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "âœ… Current branch: $CURRENT_BRANCH"
        else
          echo "::warning::Unable to determine current branch (detached HEAD?)"
        fi

    # ================== ğŸš€ ==================

    - name: "ğŸ”¢ Generate version numbers"
      id: generate
      shell: bash
      run: |
        echo "::debug::Calculating version numbers based on Git tags and branch information"

        # Helper function to set environment variables and outputs
        setEnvironmentVariable() {
            echo "$1=$2" >> "$GITHUB_ENV"
            echo "ğŸ”§ Environment variable set: $1=$2"
            echo "$1=$2" >> "$GITHUB_OUTPUT"
            echo "ğŸ“¤ Output set: $1=$2"
        }

        # Input values
        major_version="${{ steps.major-minor-validation.outputs.major }}"
        minor_version="${{ steps.major-minor-validation.outputs.minor }}"
        main_branch="${{ inputs.main-branch }}"
        build_id="${{ inputs.build-id }}"
        tag_prefix="${{ inputs.tag-prefix }}"
        branch_suffix_max_length="${{ inputs.branch-suffix-max-length }}"

        echo "ğŸ“Š Input parameters:"
        echo "  ğŸ”¢ Major: $major_version"
        echo "  ğŸ”¢ Minor: $minor_version"
        echo "  ğŸŒ¿ Main branch: $main_branch"
        echo "  ğŸ†” Build ID: $build_id"
        echo "  ğŸ·ï¸ Tag prefix: $tag_prefix"

        # Get current branch name
        if [ "${{ github.head_ref }}" != "" ]; then
          # For pull requests
          branch_name="${{ github.head_ref }}"
        else
          # For push events
          branch_name="${{ github.ref_name }}"
        fi

        echo "ğŸŒ¿ Current branch: $branch_name"

        # Find the highest patch version for the given major.minor
        echo "::debug::Searching for existing tags matching ${major_version}.${minor_version}.*"

        # Get all tags that match the pattern major.minor.patch (with optional prefix)
        if [ -n "$tag_prefix" ]; then
          MATCHING_TAGS=$(git tag -l "${tag_prefix}${major_version}.${minor_version}.*" | sort -V)
        else
          MATCHING_TAGS=$(git tag -l "${major_version}.${minor_version}.*" | sort -V)
        fi

        patch_version=0
        latest_tag=""

        if [ -n "$MATCHING_TAGS" ]; then
          echo "ğŸ“‹ Found matching tags:"
          echo "$MATCHING_TAGS" | while read -r tag; do
            echo "  ğŸ·ï¸ $tag"
          done

          # Get the latest tag and extract patch version
          latest_tag=$(echo "$MATCHING_TAGS" | tail -1)
          echo "ğŸ” Latest matching tag: $latest_tag"

          # Extract patch version from the latest tag
          if [ -n "$tag_prefix" ]; then
            version_part=${latest_tag#$tag_prefix}
          else
            version_part=$latest_tag
          fi

          # Parse major.minor.patch from version_part
          if [[ "$version_part" =~ ^[0-9]+\.[0-9]+\.([0-9]+) ]]; then
            existing_patch=${BASH_REMATCH[1]}
            patch_version=$((existing_patch + 1))
            echo "ğŸ“ˆ Incrementing patch from $existing_patch to $patch_version"
          else
            echo "::warning::Could not parse patch version from tag, starting at 0"
            patch_version=0
          fi
        else
          echo "ğŸ“‹ No existing tags found for ${major_version}.${minor_version}, starting patch at 0"
          patch_version=0
        fi

        # Build core version
        version_core="${major_version}.${minor_version}.${patch_version}"
        echo "ğŸ¯ Core version: $version_core"

        # Handle branch-specific versioning
        if [ "$branch_name" = "$main_branch" ]; then
          echo "ğŸŒ¿ On main branch - no suffix/revision"
          suffix=""
          revision_version=""
          version_extension=""
          is_prerelease="false"
        else
          echo "ğŸŒ¿ On feature branch - adding suffix and revision"
          echo "::debug::Original branch name: '$branch_name'"

          # Clean and truncate branch name for suffix
          # Replace non-alphanumeric characters with hyphens, then clean up multiple consecutive hyphens
          suffix=$(echo "$branch_name" | sed 's/[^a-zA-Z0-9]/-/g' | sed 's/-\+/-/g' | sed 's/^-\|-$//g' | tr '[:upper:]' '[:lower:]')
          echo "::debug::After character replacement: '$suffix'"

          if [ ${#suffix} -gt $branch_suffix_max_length ]; then
            original_suffix="$suffix"
            suffix=${suffix:0:$branch_suffix_max_length}
            # Remove trailing hyphens that might result from truncation
            suffix=$(echo "$suffix" | sed 's/-*$//')
            echo "::debug::Truncated from '$original_suffix' to '$suffix'"
          fi

          revision_version="$build_id"
          version_extension="${suffix}.${revision_version}"
          is_prerelease="true"

          echo "ğŸ“ Suffix: $suffix"
          echo "ğŸ”„ Revision: $revision_version"
          echo "ğŸ”— Extension: $version_extension"
          echo "ğŸš§ Prerelease: $is_prerelease"
        fi

        # Build full version
        if [ -n "$version_extension" ]; then
          version_full="${version_core}-${version_extension}"
        else
          version_full="$version_core"
        fi

        # Build assembly version (always includes build_id as 4th component)
        version_assembly="${major_version}.${minor_version}.${patch_version}.${build_id}"
        version_for_tag="${tag_prefix}${version_full}"

        echo "ğŸ“¦ Final versions:"
        echo "  ğŸ¯ Core: $version_core"
        echo "  ğŸ”— Extension: $version_extension"
        echo "  ğŸ¯ Full: $version_full"
        echo "  ğŸ“š Assembly: $version_assembly"
        echo "  ğŸ·ï¸ For Tag: $version_for_tag"

        # Check if the version tag already exists
        potential_tag="${tag_prefix}${version_full}"
        if git tag -l | grep -q "^${potential_tag}$"; then
          tag_exists="true"
          echo "âš ï¸ Tag already exists: $potential_tag"
        else
          tag_exists="false"
          echo "âœ… Tag does not exist: $potential_tag"
        fi

        # Set all environment variables and outputs
        setEnvironmentVariable "VERSION_MAJOR" "$major_version"
        setEnvironmentVariable "VERSION_MINOR" "$minor_version"
        setEnvironmentVariable "VERSION_PATCH" "$patch_version"
        setEnvironmentVariable "VERSION_PREFIX" "$tag_prefix"
        setEnvironmentVariable "VERSION_SUFFIX" "$suffix"
        setEnvironmentVariable "VERSION_REVISION" "$revision_version"
        setEnvironmentVariable "VERSION_ISPRERELEASE" "$is_prerelease"
        setEnvironmentVariable "VERSION_BUILDID" "$build_id"
        setEnvironmentVariable "VERSION_CORE" "$version_core"
        setEnvironmentVariable "VERSION_EXTENSION" "$version_extension"
        setEnvironmentVariable "VERSION_FULL" "$version_full"
        setEnvironmentVariable "VERSION_ASSEMBLY" "$version_assembly"
        setEnvironmentVariable "VERSION_FORTAG" "$version_for_tag"
        setEnvironmentVariable "VERSION_BRANCHNAME" "$branch_name"
        setEnvironmentVariable "VERSION_TAG_EXISTS" "$tag_exists"
        setEnvironmentVariable "VERSION_LATEST_TAG" "$latest_tag"
        setEnvironmentVariable "VERSION_SCRIPTCALLED" "true"

        # Check if running in dry-run mode
        if [ "${{ inputs.dry-run }}" = "true" ]; then
          echo "ğŸ§ª Running in dry-run mode - skipping file generation"
          setEnvironmentVariable "VERSION_OUTPUTTXT" ""
          setEnvironmentVariable "VERSION_OUTPUTPROPS" ""
          setEnvironmentVariable "VERSION_OUTPUTJSON" ""
        else
          # Generate txt file if requested
          output_txt="${{ steps.normalize-output-txt.outputs.normalized }}"
          if [ -n "$output_txt" ]; then
            echo "ğŸ“ Generating txt file: $output_txt"
            mkdir -p "$(dirname "$output_txt")" && touch "$output_txt"
            {
              echo "VERSION_MAJOR=$major_version"
              echo "VERSION_MINOR=$minor_version"
              echo "VERSION_PATCH=$patch_version"
              echo "VERSION_PREFIX=$tag_prefix"
              echo "VERSION_SUFFIX=$suffix"
              echo "VERSION_REVISION=$revision_version"
              echo "VERSION_ISPRERELEASE=$is_prerelease"
              echo "VERSION_BUILDID=$build_id"
              echo "VERSION_CORE=$version_core"
              echo "VERSION_EXTENSION=$version_extension"
              echo "VERSION_FULL=$version_full"
              echo "VERSION_ASSEMBLY=$version_assembly"
              echo "VERSION_FORTAG=$version_for_tag"
              echo "VERSION_BRANCHNAME=$branch_name"
              echo "VERSION_SCRIPTCALLED=true"
            } > "$output_txt"
            echo "âœ… Generated $output_txt"
            setEnvironmentVariable "VERSION_OUTPUTTXT" "$output_txt"
          fi

          # Generate props file if requested
          output_props="${{ steps.normalize-output-props.outputs.normalized }}"
          if [ -n "$output_props" ]; then
            echo "ğŸ“ Generating props file: $output_props"
            mkdir -p "$(dirname "$output_props")" && touch "$output_props"
            {
              echo "<Project>"
              echo "    <PropertyGroup>"
              echo "        <Version_Major>$major_version</Version_Major>"
              echo "        <Version_Minor>$minor_version</Version_Minor>"
              echo "        <Version_Patch>$patch_version</Version_Patch>"
              echo "        <Version_Prefix>$tag_prefix</Version_Prefix>"
              echo "        <Version_Suffix>$suffix</Version_Suffix>"
              echo "        <Version_Revision>$revision_version</Version_Revision>"
              echo "        <Version_IsPrerelease>$is_prerelease</Version_IsPrerelease>"
              echo "        <Version_BuildId>$build_id</Version_BuildId>"
              echo "        <Version_Core>$version_core</Version_Core>"
              echo "        <Version_Extension>$version_extension</Version_Extension>"
              echo "        <Version_Full>$version_full</Version_Full>"
              echo "        <Version_Assembly>$version_assembly</Version_Assembly>"
              echo "        <Version_ForTag>$version_for_tag</Version_ForTag>"
              echo "        <Version_BranchName>$branch_name</Version_BranchName>"
              echo "        <Version_ScriptCalled>true</Version_ScriptCalled>"
              echo "    </PropertyGroup>"
              echo "</Project>"
            } > "$output_props"
            echo "âœ… Generated $output_props"
            setEnvironmentVariable "VERSION_OUTPUTPROPS" "$output_props"
          fi

          # Generate JSON file if requested
          output_json="${{ steps.normalize-output-json.outputs.normalized }}"
          if [ -n "$output_json" ]; then
            echo "ğŸ“ Generating JSON file: $output_json"
            mkdir -p "$(dirname "$output_json")" && touch "$output_json"
            {
              echo "{"
              echo "  \"VERSION_MAJOR\": \"$major_version\","
              echo "  \"VERSION_MINOR\": \"$minor_version\","
              echo "  \"VERSION_PATCH\": \"$patch_version\","
              echo "  \"VERSION_PREFIX\": \"$tag_prefix\","
              echo "  \"VERSION_SUFFIX\": \"$suffix\","
              echo "  \"VERSION_REVISION\": \"$revision_version\","
              echo "  \"VERSION_ISPRERELEASE\": $is_prerelease,"
              echo "  \"VERSION_BUILDID\": \"$build_id\","
              echo "  \"VERSION_CORE\": \"$version_core\","
              echo "  \"VERSION_EXTENSION\": \"$version_extension\","
              echo "  \"VERSION_FULL\": \"$version_full\","
              echo "  \"VERSION_ASSEMBLY\": \"$version_assembly\","
              echo "  \"VERSION_FORTAG\": \"$version_for_tag\","
              echo "  \"VERSION_BRANCHNAME\": \"$branch_name\","
              echo "  \"VERSION_SCRIPTCALLED\": true"
              echo "}"
            } > "$output_json"
            echo "âœ… Generated $output_json"
            setEnvironmentVariable "VERSION_OUTPUTJSON" "$output_json"
          fi
        fi  # End of dry-run check

        echo "âœ… Version generation completed successfully"

    # ================== ğŸ” ==================
    - name: "ğŸ” Verify generated versions"
      id: verify
      shell: bash
      run: |
        echo "::debug::Verifying generated versions..."

        # Verify all required outputs are set
        REQUIRED_VARS=(
          "VERSION_MAJOR" "VERSION_MINOR" "VERSION_PATCH"
          "VERSION_CORE" "VERSION_FULL" "VERSION_ASSEMBLY"
          "VERSION_BRANCHNAME" "VERSION_BUILDID" "VERSION_PREFIX"
          "VERSION_FORTAG"
        )

        for var in "${REQUIRED_VARS[@]}"; do
          if [ -z "${!var:-}" ]; then
            echo "::error::Required variable $var is not set"
            exit 1
          else
            echo "âœ… $var=${!var}"
          fi
        done

        # Verify semantic version format
        if ! [[ "$VERSION_CORE" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "::error::Invalid semantic version format: $VERSION_CORE"
          exit 1
        fi

        # Verify assembly version format
        if ! [[ "$VERSION_ASSEMBLY" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "::error::Invalid assembly version format: $VERSION_ASSEMBLY"
          exit 1
        fi

        # Verify output files if they were requested
        if [ -n "${{ inputs.output-txt }}" ]; then
          if [ -f "${{ steps.normalize-output-txt.outputs.normalized }}" ]; then
            echo "âœ… Output txt file created: ${{ steps.normalize-output-txt.outputs.normalized }}"
            echo "::debug::Content preview:"
            head -5 "${{ steps.normalize-output-txt.outputs.normalized }}" | sed 's/^/  /'
          else
            echo "::error file=${{ steps.normalize-output-txt.outputs.normalized }}::Output txt file not created: ${{ steps.normalize-output-txt.outputs.normalized }}"
            exit 1
          fi
        fi

        if [ -n "${{ inputs.output-props }}" ]; then
          if [ -f "${{ steps.normalize-output-props.outputs.normalized }}" ]; then
            echo "âœ… Output props file created: ${{ steps.normalize-output-props.outputs.normalized }}"
            echo "::debug::Content preview:"
            head -10 "${{ steps.normalize-output-props.outputs.normalized }}" | sed 's/^/  /'
          else
            echo "::error file=${{ steps.normalize-output-props.outputs.normalized }}::Output props file not created: ${{ steps.normalize-output-props.outputs.normalized }}"
            exit 1
          fi
        fi

        if [ -n "${{ inputs.output-json }}" ]; then
          if [ -f "${{ steps.normalize-output-json.outputs.normalized }}" ]; then
            echo "âœ… Output JSON file created: ${{ steps.normalize-output-json.outputs.normalized }}"
            echo "::debug::Content preview:"
            head -10 "${{ steps.normalize-output-json.outputs.normalized }}" | sed 's/^/  /'
            # Validate JSON format
            if command -v jq >/dev/null 2>&1; then
              if jq empty "${{ steps.normalize-output-json.outputs.normalized }}" 2>/dev/null; then
                echo "âœ… JSON file is valid"
              else
                echo "::error::Generated JSON file is invalid"
                exit 1
              fi
            elif command -v python3 >/dev/null 2>&1; then
              if python3 -m json.tool "${{ steps.normalize-output-json.outputs.normalized }}" >/dev/null 2>&1; then
                echo "âœ… JSON file is valid"
              else
                echo "::error::Generated JSON file is invalid"
                exit 1
              fi
            else
              echo "::warning::Neither jq nor python3 available for JSON validation"
            fi
          else
            echo "::error file=${{ steps.normalize-output-json.outputs.normalized }}::Output JSON file not created: ${{ steps.normalize-output-json.outputs.normalized }}"
            exit 1
          fi
        fi

        echo "âœ… Version verification completed successfully"

    # ================== ğŸ“Š ==================

    - name: "ğŸ“Š Action Summary"
      if: always() && inputs.show-summary == 'true'
      shell: bash
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        <details><summary>ğŸ”¢ Generate Version : ${{ steps.generate.outputs.VERSION_FULL }}</summary>

        ## ğŸ”§ Input Parameters
        | Parameter | Value |
        |-----------|-------|
        | ğŸ”¢ Major Version | `${{ steps.major-minor-validation.outputs.major }}` |
        | ğŸ”¢ Minor Version | `${{ steps.major-minor-validation.outputs.minor }}` |
        | ğŸŒ¿ Main Branch | `${{ inputs.main-branch }}` |
        | ğŸ†” Build ID | `${{ inputs.build-id }}` |
        | ğŸ·ï¸ Tag Prefix | `${{ inputs.tag-prefix }}` |
        | ğŸ“ Branch Suffix Max Length | `${{ inputs.branch-suffix-max-length }}` |
        | ğŸ§ª Dry Run | `${{ inputs.dry-run }}` |
        | ğŸ” Fetch Depth | `${{ inputs.fetch-depth }}` |

        ## ğŸ“¤ Generated Versions
        | Version Type | Value |
        |--------------|-------|
        | ğŸ¯ Core Version | `${{ steps.generate.outputs.VERSION_CORE }}` |
        | ğŸ”— Full Version | `${{ steps.generate.outputs.VERSION_FULL }}` |
        | ğŸ“š Assembly Version | `${{ steps.generate.outputs.VERSION_ASSEMBLY }}` |
        | ğŸ·ï¸ For Tag | `${{ steps.generate.outputs.VERSION_FORTAG }}` |
        | ğŸŒ¿ Branch Name | `${{ steps.generate.outputs.VERSION_BRANCHNAME }}` |
        | ğŸ·ï¸ Tag Prefix | `${{ steps.generate.outputs.VERSION_PREFIX }}` |
        | ğŸ“ Suffix | `${{ steps.generate.outputs.VERSION_SUFFIX || 'none' }}` |
        | ğŸ”„ Revision | `${{ steps.generate.outputs.VERSION_REVISION || 'none' }}` |
        | ğŸ·ï¸ Tag Exists | `${{ steps.generate.outputs.VERSION_TAG_EXISTS }}` |
        | ğŸ“‹ Latest Tag | `${{ steps.generate.outputs.VERSION_LATEST_TAG || 'none' }}` |

        ## ğŸ“ Output Files
        | File Type | Path | Status |
        |-----------|------|--------|
        | ğŸ“ Txt File | `${{ inputs.output-txt || 'not requested' }}` | `${{ inputs.output-txt != '' && 'âœ… Generated' || 'â­ï¸ Skipped' }}` |
        | ğŸ“„ Props File | `${{ inputs.output-props || 'not requested' }}` | `${{ inputs.output-props != '' && 'âœ… Generated' || 'â­ï¸ Skipped' }}` |
        | ğŸ“‹ JSON File | `${{ inputs.output-json || 'not requested' }}` | `${{ inputs.output-json != '' && 'âœ… Generated' || 'â­ï¸ Skipped' }}` |

        ## ğŸ”§ Process Details
        | Step | Status |
        |------|--------|
        | âœ… Input Validation | `âœ… Completed` |
        | ğŸ” Git History Fetch | `âœ… Completed` |
        | ğŸ”¢ Version Generation | `${{ steps.generate.outcome == 'success' && 'âœ… Completed' || 'âŒ Failed' }}` |
        | ğŸ” Version Verification | `${{ steps.verify.outcome == 'success' && 'âœ… Completed' || 'âŒ Failed' }}` |

        ## ğŸ“‹ Version Components Breakdown
        | Component | Value | Description |
        |-----------|-------|-------------|
        | Major | `${{ steps.generate.outputs.VERSION_MAJOR }}` | Major version number (input) |
        | Minor | `${{ steps.generate.outputs.VERSION_MINOR }}` | Minor version number (input) |
        | Patch | `${{ steps.generate.outputs.VERSION_PATCH }}` | Auto-incremented from Git tags |
        | Build ID | `${{ steps.generate.outputs.VERSION_BUILDID }}` | Build identifier for this run |
        | Extension | `${{ steps.generate.outputs.VERSION_EXTENSION || 'none' }}` | Branch-specific version extension |

        </details>
        EOF

branding:
  icon: "hash"
  color: "blue"
