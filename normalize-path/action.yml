name: '📁 Normalize Path'
description: 'Normalizes a file path according to the runner OS and provides both relative and absolute formats'
author: 'Francois Raminosona'

inputs:
  path:
    description: 'Path to normalize (can be relative or absolute, can be empty)'
    required: false
    default: ''
  show-summary:
    description: 'Whether to show the action summary'
    required: false
    default: 'false'

outputs:
  normalized:
    description: 'Normalized path adjusted for the current OS'
    value: ${{ steps.normalize-path.outputs.normalized }}
  absolute:
    description: 'Absolute path resolved from the normalized path'
    value: ${{ steps.normalize-path.outputs.absolute }}
  exists:
    description: 'Whether the normalized path exists on the filesystem'
    value: ${{ steps.normalize-path.outputs.exists }}

runs:
  using: "composite"
  steps:
    # ================== ℹ️ ==================

    - name: "ℹ️ Gather environment information"
      shell: bash
      run: |
        echo "::debug::Operating System: $(uname -a)"
        echo "::debug::GitHub Runner OS: $RUNNER_OS"
        echo "::debug::GitHub Runner Version: $RUNNER_VERSION"
        echo "::debug::Shell: $SHELL"
        echo "::debug::OS Type: $OSTYPE"

    # ================== ✅ ==================

    - name: "✅ Validate inputs"
      shell: bash
      run: |
        echo "::group::🔍 Input Validation"
        echo "::debug::Validating inputs for path normalization"

        # Handle empty path - this is now allowed
        if [ -z "${{ inputs.path }}" ]; then
          echo "::debug::Path parameter is empty - will return empty results"
        else
          # Check for potentially dangerous paths
          if [[ "${{ inputs.path }}" == *".."* ]]; then
            echo "::warning::Path '${{ inputs.path }}' contains parent directory references (..), ensure this is intentional"
          fi

          # Check for reserved characters on Windows
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            INPUT_PATH="${{ inputs.path }}"
            INVALID_CHARS=""

            # Check each reserved character individually
            [[ "$INPUT_PATH" == *"<"* ]] && INVALID_CHARS="${INVALID_CHARS}<, "
            [[ "$INPUT_PATH" == *">"* ]] && INVALID_CHARS="${INVALID_CHARS}>, "
            # [[ "$INPUT_PATH" == *":"* ]] && INVALID_CHARS="${INVALID_CHARS}:, " # this is okay, part of a normal path on Windows (D:...)
            [[ "$INPUT_PATH" == *"\""* ]] && INVALID_CHARS="${INVALID_CHARS}\", "
            [[ "$INPUT_PATH" == *"|"* ]] && INVALID_CHARS="${INVALID_CHARS}|, "
            [[ "$INPUT_PATH" == *"?"* ]] && INVALID_CHARS="${INVALID_CHARS}?, "
            [[ "$INPUT_PATH" == *"*"* ]] && INVALID_CHARS="${INVALID_CHARS}*, "

            if [[ -n "$INVALID_CHARS" ]]; then
              # Remove trailing comma and space
              INVALID_CHARS="${INVALID_CHARS%, }"
              echo "::warning::Path '$INPUT_PATH' contains Windows-reserved characters: [$INVALID_CHARS]. These may cause file system operations to fail on Windows."
            fi
          fi
        fi

        echo "::debug::Input validation completed successfully"
        echo "::debug::Path to normalize: '${{ inputs.path }}'"
        echo "::endgroup::"

    # ================== 🚀 ==================

    - name: "🔧 Normalize path"
      id: normalize-path
      shell: bash
      run: |
        echo "::group::🚀 Normalizing path"
        echo "::debug::Processing path normalization for: '${{ inputs.path }}'"

        INPUT_PATH="${{ inputs.path }}"

        # Handle empty path - return empty results
        if [ -z "$INPUT_PATH" ]; then
          echo "::debug::Input path is empty, returning empty results"
          echo "normalized=" >> $GITHUB_OUTPUT
          echo "absolute=" >> $GITHUB_OUTPUT
          echo "exists=false" >> $GITHUB_OUTPUT

          echo "::debug::Path normalization completed (empty path handled)"
          echo "::debug::Normalized: (empty)"
          echo "::debug::Absolute: (empty)"
          echo "::debug::Exists: false"
          echo "::endgroup::"
          exit 0
        fi

        # Convert path separators based on OS
        if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" || "$OSTYPE" == "cygwin" ]]; then
          # Windows: convert forward slashes to backslashes
          NORMALIZED=$(echo "$INPUT_PATH" | sed 's|/|\\|g')
        else
          # Unix: convert backslashes to forward slashes
          NORMALIZED=$(echo "$INPUT_PATH" | sed 's|\\|/|g')
        fi

        # Remove redundant slashes and resolve . and ..
        # Use realpath if available, otherwise use a simpler approach
        if command -v realpath &> /dev/null; then
          if [ -e "$NORMALIZED" ]; then
            ABSOLUTE=$(realpath "$NORMALIZED" 2>/dev/null || echo "$PWD/$NORMALIZED")
            EXISTS="true"
          else
            ABSOLUTE="$PWD/$NORMALIZED"
            EXISTS="false"
          fi
        else
          # Fallback: construct absolute path manually
          if [[ "$NORMALIZED" == /* ]] || [[ "$NORMALIZED" == ?:* ]]; then
            ABSOLUTE="$NORMALIZED"
          else
            ABSOLUTE="$PWD/$NORMALIZED"
          fi

          if [ -e "$NORMALIZED" ]; then
            EXISTS="true"
          else
            EXISTS="false"
          fi
        fi

        # Normalize the path (remove ./ and resolve ..)
        NORMALIZED=$(echo "$NORMALIZED" | sed 's|^\./||' | sed 's|/\./|/|g')

        # Set outputs
        echo "normalized=$NORMALIZED" >> $GITHUB_OUTPUT
        echo "absolute=$ABSOLUTE" >> $GITHUB_OUTPUT
        echo "exists=$EXISTS" >> $GITHUB_OUTPUT

        echo "::debug::Path normalization completed successfully"
        echo "::debug::Normalized: $NORMALIZED"
        echo "::debug::Absolute: $ABSOLUTE"
        echo "::debug::Exists: $EXISTS"
        echo "::endgroup::"

    # ================== 🔍 ==================

    - name: "🔍 Verify normalization results"
      shell: bash
      run: |
        echo "::group::🔍 Verifying Normalization Results"

        # Handle empty path case - outputs should all be empty/false
        if [ -z "${{ inputs.path }}" ]; then
          echo "::debug::Verifying empty path results"

          # Verify empty normalized output
          if [ -n "${{ steps.normalize-path.outputs.normalized }}" ]; then
            echo "::error::Expected empty normalized path for empty input, got: '${{ steps.normalize-path.outputs.normalized }}'"
            exit 1
          fi

          # Verify empty absolute output
          if [ -n "${{ steps.normalize-path.outputs.absolute }}" ]; then
            echo "::error::Expected empty absolute path for empty input, got: '${{ steps.normalize-path.outputs.absolute }}'"
            exit 1
          fi

          # Verify exists is false
          if [ "${{ steps.normalize-path.outputs.exists }}" != "false" ]; then
            echo "::error::Expected exists=false for empty input, got: '${{ steps.normalize-path.outputs.exists }}'"
            exit 1
          fi

          echo "::debug::Empty path normalization verification completed successfully"
          echo "::endgroup::"
          exit 0
        fi

        # Verify that normalized output was generated (for non-empty paths)
        if [ -z "${{ steps.normalize-path.outputs.normalized }}" ]; then
          echo "::error::Normalization failed - no normalized path generated"
          exit 1
        fi

        # Verify that absolute path was generated
        if [ -z "${{ steps.normalize-path.outputs.absolute }}" ]; then
          echo "::error::Normalization failed - no absolute path generated"
          exit 1
        fi

        # Verify exists output is boolean
        EXISTS_VALUE="${{ steps.normalize-path.outputs.exists }}"
        if [ "$EXISTS_VALUE" != "true" ] && [ "$EXISTS_VALUE" != "false" ]; then
          echo "::error::Invalid exists value: $EXISTS_VALUE (should be true or false)"
          exit 1
        fi

        echo "::debug::Path normalization verification completed successfully"
        echo "::debug::Verified normalized path: ${{ steps.normalize-path.outputs.normalized }}"
        echo "::debug::Verified absolute path: ${{ steps.normalize-path.outputs.absolute }}"
        echo "::debug::Verified exists status: ${{ steps.normalize-path.outputs.exists }}"
        echo "::endgroup::"

    # ================== 📊 ==================

    - name: "📊 Action Summary"
      if: always() && inputs.show-summary == 'true'
      shell: bash
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        <details><summary>Expand for details - 📊 Path Normalization Summary</summary>

        ## 🔧 Input Parameters
        | Parameter | Value |
        |-----------|-------|
        | 📁 Original Path | `${{ inputs.path }}` |
        | 🖥️ Runner OS | `${{ runner.os }}` |

        ## 📤 Normalization Results
        | Metric | Value |
        |--------|-------|
        | 📁 Normalized Path | `${{ steps.normalize-path.outputs.normalized }}` |
        | 🎯 Absolute Path | `${{ steps.normalize-path.outputs.absolute }}` |
        | ✅ Path Exists | `${{ steps.normalize-path.outputs.exists }}` |
        | 🔧 Status | `${{ steps.normalize-path.outcome }}` |

        ## ⚙️ Process Details
        | Step | Status |
        |------|--------|
        | ✅ Input Validation | `✅ Completed` |
        | 🔧 Path Normalization | `${{ steps.normalize-path.outcome == 'success' && '✅ Completed' || '❌ Failed' }}` |

        ## 📋 Path Analysis
        - **Original**: `${{ inputs.path }}`
        - **Normalized**: `${{ steps.normalize-path.outputs.normalized }}`
        - **Absolute**: `${{ steps.normalize-path.outputs.absolute }}`
        - **Exists**: ${{ steps.normalize-path.outputs.exists == 'true' && '✅ Yes' || '❌ No' }}

        </details>
        EOF

branding:
  icon: 'folder'
  color: 'blue'
