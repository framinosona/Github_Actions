name: "ğŸš€ Run .NET Command"
description: "Runs a .NET command with automatic verbosity handling based on debug settings"
author: "Francois Raminosona"

inputs:
  command:
    description: "The dotnet command to run (e.g., 'build', 'restore', 'test')"
    required: true
  path:
    description: "Path to the project file, solution file, or directory to operate on"
    required: false
    default: ""
  arguments:
    description: "Additional arguments to pass to the dotnet command"
    required: false
    default: ""
  working-directory:
    description: "Working directory for the command"
    required: false
    default: "."
  verbosity:
    description: "Force a specific verbosity level (overrides auto-detection)"
    required: false
    default: ""
  nologo:
    description: "Suppress the Microsoft logo and startup information"
    required: false
    default: "true"
  no-restore:
    description: "Skip automatic restore"
    required: false
    default: "false"
  no-build:
    description: "Skip building the project before running"
    required: false
    default: "false"
  configuration:
    description: "Build configuration to use (e.g., 'Debug', 'Release')"
    required: false
    default: "Release"
  framework:
    description: "Target framework (e.g., 'net8.0', 'net6.0')"
    required: false
    default: ""
  runtime:
    description: "Target runtime (e.g., 'win-x64', 'linux-x64', 'osx-arm64')"
    required: false
    default: ""
  arch:
    description: "Target architecture (e.g., 'x64', 'arm64')"
    required: false
    default: ""
  output:
    description: "Output directory path, will convert into "
    required: false
    default: ""
  artifacts-path:
    description: "Path to store artifacts (if applicable)"
    required: false
    default: ""
  show-summary:
    description: "Whether to show the action summary"
    required: false
    default: "false"

outputs:
  exit-code:
    description: "Exit code of the dotnet command"
    value: ${{ steps.run-command.outputs.exit-code }}
  executed-command:
    description: "The actual command that was executed"
    value: ${{ steps.run-command.outputs.executed-command }}

runs:
  using: "composite"
  steps:
    - name: "â„¹ï¸ Environment info"
      shell: bash
      run: |
        echo "â„¹ï¸ Working directory: $(pwd)"
        echo "â„¹ï¸ .NET version: $(dotnet --version 2>/dev/null || echo 'Not found')"
        echo "â„¹ï¸ Available runtimes: $(dotnet --list-runtimes 2>/dev/null || echo 'None')"

        # Reset environment variable

    - name: "âœ… Validate input : booleans"
      shell: bash
      run: |
        echo "::debug::Validating boolean inputs..."
        for param in nologo no-restore no-build; do
          case $param in
            nologo) value="${{ inputs.nologo }}" ;;
            no-restore) value="${{ inputs.no-restore }}" ;;
            no-build) value="${{ inputs.no-build }}" ;;
          esac
          if [ -n "$value" ] && [ "$value" != "true" ] && [ "$value" != "false" ]; then
            echo "::error::Parameter $param must be 'true' or 'false', got: $value"
            exit 1
          fi
        done

        echo "âœ… Boolean inputs validation completed successfully"

    - name: "âœ… Validate input : command"
      shell: bash
      run: |
        echo "::debug::Validating command input: ${{ inputs.command }}"

        if [ -z "${{ inputs.command }}" ]; then
          echo "::error::Command input is required"
          exit 1
        fi

        echo "âœ… Command validation completed successfully"

    - name: "âœ… Validate input : path"
      if: ${{ inputs.path != '' }}
      shell: bash
      run: |
        echo "::debug::Validating path input: ${{ inputs.path }}"

        if [ ! -e "${{ inputs.path }}" ]; then
          echo "::error file=${{ inputs.path }}::Specified path does not exist: ${{ inputs.path }}"
          exit 1
        fi

        echo "âœ… Path validation completed successfully"

    - name: "âœ… Validate input : working-directory"
      shell: bash
      run: |
        echo "::debug::Validating working-directory input: ${{ inputs.working-directory }}"

        if [ -z "${{ inputs.working-directory }}" ]; then
          echo "::error::Working directory input is required"
          exit 1
        fi

        if [ ! -d "${{ inputs.working-directory }}" ]; then
          echo "::error file=${{ inputs.working-directory }}::Working directory does not exist or is not a directory: ${{ inputs.working-directory }}"
          exit 1
        fi

        echo "âœ… Working directory validation completed successfully"

    - name: "âœ… Validate input : verbosity"
      if: ${{ inputs.verbosity != '' }}
      shell: bash
      run: |
        echo "::debug::Validating verbosity input: ${{ inputs.verbosity }}"

        case "${{ inputs.verbosity }}" in
          quiet|minimal|normal|detailed|diagnostic) ;;
          *) echo "::error::Invalid verbosity level: ${{ inputs.verbosity }}. Must be one of: quiet, minimal, normal, detailed, diagnostic"; exit 1 ;;
        esac

        echo "âœ… Verbosity validation completed successfully"

    - name: "ğŸ”§ Set verbosity level"
      id: validate-verbosity
      shell: bash
      run: |
        if [ -n "${{ inputs.verbosity }}" ]; then
          echo "verbosity=${{ inputs.verbosity }}" >> $GITHUB_OUTPUT
        elif [ "$RUNNER_DEBUG" == "true" ] || [ "$ACTIONS_STEP_DEBUG" == "true" ]; then
          echo "verbosity=diagnostic" >> $GITHUB_OUTPUT
        else
          echo "verbosity=minimal" >> $GITHUB_OUTPUT
        fi

    - name: "âœ… Validate input : configuration"
      if: ${{ inputs.configuration != '' }}
      shell: bash
      run: |
        echo "::debug::Validating configuration input: ${{ inputs.configuration }}"

        case "${{ inputs.configuration }}" in
          Debug|Release|MinSizeRel|RelWithDebInfo) ;;
          *) echo "::warning::Unusual configuration value: ${{ inputs.configuration }}" ;;
        esac

        echo "âœ… Configuration validation completed successfully"

    - name: "âœ… Validate input : framework"
      if: ${{ inputs.framework != '' }}
      shell: bash
      run: |
        echo "::debug::Validating framework input: ${{ inputs.framework }}"

        if ! [[ "${{ inputs.framework }}" =~ ^(net[0-9]+\.[0-9]+|netstandard[0-9]+\.[0-9]+|netcoreapp[0-9]+\.[0-9]+|netframework[0-9]+\.[0-9]+)$ ]]; then
          echo "::warning::Framework format may be invalid: ${{ inputs.framework }}"
        fi

        echo "âœ… Framework validation completed successfully"

    - name: "âœ… Validate input : runtime"
      if: ${{ inputs.runtime != '' }}
      shell: bash
      run: |
        echo "::debug::Validating runtime input: ${{ inputs.runtime }}"

        if ! [[ "${{ inputs.runtime }}" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]; then
          echo "::warning::Runtime identifier format may be invalid: ${{ inputs.runtime }}"
        fi

        echo "âœ… Runtime validation completed successfully"

    - name: "âœ… Validate input : arch"
      if: ${{ inputs.arch != '' }}
      shell: bash
      run: |
        echo "::debug::Validating arch input: ${{ inputs.arch }}"

        if ! [[ "${{ inputs.arch }}" =~ ^(x86|x64|arm|arm64)$ ]]; then
          echo "::warning::Arch format may be invalid: ${{ inputs.arch }}"
        fi

        echo "âœ… Arch validation completed successfully"

    - name: "ğŸ—ï¸ Build argument list"
      id: build-args
      shell: bash
      run: |
        echo "::debug::Building argument list..."

        # Define command support maps (cached for performance)
        declare -A COMMAND_SUPPORT=(
          ["verbosity"]="build|restore|pack|publish|test|clean|msbuild|workload"
          ["configuration"]="build|publish|test|pack|run"
          ["framework"]="build|publish|test|pack|run"
          ["runtime"]="build|publish|test|pack|run"
          ["arch"]="build|publish|run"
          ["output"]="build|publish|pack|run|tool"
          ["nologo"]="build|restore|pack|publish|test|clean|msbuild|run|add|remove|list"
          ["no-restore"]="build|test|publish|pack"
          ["no-build"]="test|publish"
          ["artifacts-path"]="build|restore|publish|pack|test|clean|run"
        )

        # Function to check command support
        supports_option() {
          local option="$1"
          local command="${{ inputs.command }}"
          echo "$command" | grep -iqE "^(${COMMAND_SUPPORT[$option]})$"
        }

        # Start building arguments
        ARGUMENTS="${{ inputs.command }}"

        if [ -n "${{ inputs.path }}" ]; then
          ARGUMENTS="$ARGUMENTS ${{ inputs.path }}"
        fi

        # Normalize multiline arguments (convert newlines to spaces, trim whitespace)
        if [ -n "${{ inputs.arguments }}" ]; then
          NORMALIZED_ARGS=$(echo "${{ inputs.arguments }}" | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          echo "::debug::Original arguments: ${{ inputs.arguments }}"
          echo "::debug::Normalized arguments: $NORMALIZED_ARGS"
          ARGUMENTS="$ARGUMENTS $NORMALIZED_ARGS"
        fi

        # Boolean flags
        for param in nologo no-restore no-build; do
          case $param in
            nologo) value="${{ inputs.nologo }}" ;;
            no-restore) value="${{ inputs.no-restore }}" ;;
            no-build) value="${{ inputs.no-build }}" ;;
          esac
          if [ "$value" = "true" ] && supports_option "$param"; then
            ARGUMENTS="$ARGUMENTS --${param}"
          fi
        done

        # Verbosity
        if supports_option "verbosity"; then
            ARGUMENTS="$ARGUMENTS --verbosity '${{ steps.validate-verbosity.outputs.verbosity }}'"
        fi

        # Key-value options
        for param in configuration framework runtime output arch artifacts-path; do
          case $param in
            configuration) value="${{ inputs.configuration }}" ;;
            framework) value="${{ inputs.framework }}" ;;
            runtime) value="${{ inputs.runtime }}" ;;
            output) value="${{ inputs.output }}" ;;
            arch) value="${{ inputs.arch }}" ;;
            artifacts-path) value="${{ inputs.artifacts-path }}" ;;
          esac
          if [ -n "$value" ] && supports_option "$param"; then
            ARGUMENTS="$ARGUMENTS --$param '$value'"
          fi
        done

        # Trim leading space
        ARGUMENTS="${ARGUMENTS# }"

        # Store in environment for the next step
        echo "arguments=$ARGUMENTS" >> $GITHUB_OUTPUT

        echo "âœ… Argument list built successfully: $ARGUMENTS"

    - name: "ğŸš€ Run dotnet command with auto-verbosity"
      id: run-command
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::debug::Building final command from environment: ${{ steps.build-args.outputs.arguments }}"

        # Build the full command string
        FULL_COMMAND="dotnet ${{ steps.build-args.outputs.arguments }}"
        echo "::debug::Final command: $FULL_COMMAND"

        # Execute the command using eval for proper argument handling
        echo "âœ… Executing: $FULL_COMMAND"
        eval "$FULL_COMMAND"
        EXIT_CODE=$?

        # Enhanced status reporting
        if [ $EXIT_CODE -eq 0 ]; then
          echo "âœ… Command completed successfully with exit code 0"
        else
          echo "::error::Command failed with exit code $EXIT_CODE"
        fi

        # Set outputs
        echo "exit-code=$EXIT_CODE" >> $GITHUB_OUTPUT
        echo "executed-command=$FULL_COMMAND" >> $GITHUB_OUTPUT

        # Exit with the same code as the dotnet command
        exit $EXIT_CODE

    - name: "ğŸ“Š Action Summary"
      if: always() && inputs.show-summary == 'true'
      shell: bash
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        <details><summary>âš™ï¸ .NET command : ${{ inputs.command }}</summary>

        ## ğŸ”§ Input Parameters
        | Parameter | Value |
        |-----------|-------|
        | ğŸš€ Command | `${{ inputs.command }}` |
        | ğŸ“ Path | `${{ inputs.path || 'none' }}` |
        | ğŸ“ Working Directory | `${{ inputs.working-directory }}` |
        | âš™ï¸ Configuration | `${{ inputs.configuration }}` |
        | ğŸ¯ Framework | `${{ inputs.framework || 'none' }}` |
        | ğŸ–¥ï¸ Runtime | `${{ inputs.runtime || 'none' }}` |
        | ğŸ”§ Arguments | `${{ inputs.arguments || 'none' }}` |
        | ğŸ”‡ No Logo | `${{ inputs.nologo }}` |
        | ğŸš« No Restore | `${{ inputs.no-restore }}` |
        | ğŸš« No Build | `${{ inputs.no-build }}` |
        | ğŸ“¤ Output Path | `${{ inputs.output || 'none' }}` |
        | ğŸ”Š Force Verbosity | `${{ inputs.verbosity || 'auto' }}` |

        ## âš™ï¸ Process Details
        | Step | Status |
        |------|--------|
        | âœ… Input Validation | `âœ… Completed` |
        | ğŸš€ Command Construction | `${{ steps.build-args.outcome == 'success' && 'âœ… Completed' || 'âŒ Failed' }}` |
        | ğŸ”§ Compiled Arguments | `${{ steps.build-args.outputs.arguments }}` |
        | ğŸš€ Command Execution | `${{ steps.run-command.outcome == 'success' && 'âœ… Completed' || 'âŒ Failed' }}` |

        ## ğŸ“¤ Execution Results
        | Metric | Value |
        |--------|-------|
        | âœ… Exit Code | `${{ steps.run-command.outputs.exit-code }}` |
        | ğŸ“Š Status | `${{ steps.run-command.outcome }}` |
        | ğŸš€ Executed Command | `${{ steps.run-command.outputs.executed-command }}` |

        </details>
        EOF

branding:
  icon: "terminal"
  color: "blue"

# dotnet --help
# Usage: dotnet [runtime-options] [path-to-application] [arguments]

# Execute a .NET application.

# runtime-options:
#   --additionalprobingpath <path>   Path containing probing policy and assemblies to probe for.
#   --additional-deps <path>         Path to additional deps.json file.
#   --depsfile                       Path to <application>.deps.json file.
#   --fx-version <version>           Version of the installed Shared Framework to use to run the application.
#   --roll-forward <setting>         Roll forward to framework version  (LatestPatch, Minor, LatestMinor, Major, LatestMajor, Disable).
#   --runtimeconfig                  Path to <application>.runtimeconfig.json file.

# path-to-application:
#   The path to an application .dll file to execute.

# Usage: dotnet [sdk-options] [command] [command-options] [arguments]

# Execute a .NET SDK command.

# sdk-options:
#   -d|--diagnostics  Enable diagnostic output.
#   -h|--help         Show command line help.
#   --info            Display .NET information.
#   --list-runtimes   Display the installed runtimes.
#   --list-sdks       Display the installed SDKs.
#   --version         Display .NET SDK version in use.

# SDK commands:
#   build             Build a .NET project.
#   build-server      Interact with servers started by a build.
#   clean             Clean build outputs of a .NET project.
#   format            Apply style preferences to a project or solution.
#   help              Opens the reference page in a browser for the specified command.
#   msbuild           Run Microsoft Build Engine (MSBuild) commands.
#   new               Create a new .NET project or file.
#   nuget             Provides additional NuGet commands.
#   pack              Create a NuGet package.
#   package           Search for, add, remove, or list PackageReferences for a .NET project.
#   publish           Publish a .NET project for deployment.
#   reference         Add, remove, or list ProjectReferences for a .NET project.
#   restore           Restore dependencies specified in a .NET project.
#   run               Build and run a .NET project output.
#   sdk               Manage .NET SDK installation.
#   solution          Modify Visual Studio solution files.
#   store             Store the specified assemblies in the runtime package store.
#   test              Run unit tests using the test runner specified in a .NET project.
#   tool              Install or manage tools that extend the .NET experience.
#   vstest            Run Microsoft Test Engine (VSTest) commands.
#   workload          Manage optional workloads.

# Additional commands from bundled tools:
#   dev-certs         Create and manage development certificates.
#   fsi               Start F# Interactive / execute F# scripts.
#   user-jwts         Manage JSON Web Tokens in development.
#   user-secrets      Manage development user secrets.
#   watch             Start a file watcher that runs a command when files change.

# Run 'dotnet [command] --help' for more information on a command.
