name: "🚀 Run .NET Command"
description: "Runs a .NET command with automatic verbosity handling based on debug settings"
author: "Francois Raminosona"

inputs:
  command:
    description: "The dotnet command to run (e.g., 'build', 'restore', 'test')"
    required: true
  path:
    description: "Path to the project file, solution file, or directory to operate on"
    required: false
    default: ""
  arguments:
    description: "Additional arguments to pass to the dotnet command"
    required: false
    default: ""
  working-directory:
    description: "Working directory for the command"
    required: false
    default: "."
  verbosity:
    description: "Force a specific verbosity level (overrides auto-detection)"
    required: false
    default: ""
  nologo:
    description: "Suppress the Microsoft logo and startup information"
    required: false
    default: "true"
  no-restore:
    description: "Skip automatic restore"
    required: false
    default: "false"
  no-build:
    description: "Skip building the project before running"
    required: false
    default: "false"
  configuration:
    description: "Build configuration to use (e.g., 'Debug', 'Release')"
    required: false
    default: "Release"
  framework:
    description: "Target framework (e.g., 'net8.0', 'net6.0')"
    required: false
    default: ""
  runtime:
    description: "Target runtime (e.g., 'win-x64', 'linux-x64', 'osx-arm64')"
    required: false
    default: ""
  arch:
    description: "Target architecture (e.g., 'x64', 'arm64')"
    required: false
    default: ""
  output:
    description: "Output directory path, will convert into "
    required: false
    default: ""
  artifacts-path:
    description: "Path to store artifacts (if applicable)"
    required: false
    default: ""
  show-summary:
    description: "Whether to show the action summary"
    required: false
    default: "false"

outputs:
  exit-code:
    description: "Exit code of the dotnet command"
    value: ${{ steps.run-command.outputs.exit-code }}
  executed-command:
    description: "The actual command that was executed"
    value: ${{ steps.run-command.outputs.executed-command }}

runs:
  using: "composite"
  steps:

    # ================== ℹ️ ==================

    - name: "ℹ️ Gather environment information"
      shell: bash
      run: |
        echo "::debug::Operating System: $(uname -a)"
        echo "::debug::GitHub Runner OS: $RUNNER_OS"
        echo "::debug::GitHub Runner Version: $RUNNER_VERSION"
        echo "::debug::.NET SDK Version: $(dotnet --version || echo 'Not installed')"
        echo "::debug::Available runtimes: $(dotnet --list-runtimes 2>/dev/null || echo 'None')"

    # ================== 🔒 ==================

    - name: "🔒 Mask sensitive data"
      shell: bash
      run: |
        # No sensitive inputs to mask in this action
        echo "✅ No sensitive data to mask"

    # ================== 📁 ==================

    - name: "💯 Normalize arguments"
      id: normalize-arguments
      uses: framinosona/github_actions/normalize-arguments@main
      with:
        arguments: ${{ inputs.arguments }}

    - name: "📁 Normalize output"
      id: normalize-output
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.output }}

    - name: "📁 Normalize artifacts-path"
      id: normalize-artifacts-path
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.artifacts-path }}

    - name: "📁 Normalize working-directory"
      id: normalize-working-directory
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.working-directory }}

    - name: "📁 Normalize path"
      id: normalize-path
      uses: framinosona/github_actions/normalize-path@main
      with:
        path: ${{ inputs.path }}

    # ================== ✅ ==================

    - name: "✅ Validate input : working-directory"
      shell: bash
      run: |
        echo "::debug::Validating working-directory input: ${{ steps.normalize-working-directory.outputs.normalized }}"

        if [ -z "${{ steps.normalize-working-directory.outputs.normalized }}" ]; then
          echo "::error::Working directory input is required"
          exit 1
        fi

        if [ "${{ steps.normalize-working-directory.outputs.exists }}" != "true" ]; then
          echo "::error file=${{ steps.normalize-working-directory.outputs.normalized }}::Working directory does not exist or is not a directory: ${{ steps.normalize-working-directory.outputs.normalized }}"
          exit 1
        fi

        echo "✅ Working directory validation completed successfully"

    - name: "✅ Validate input : path"
      if: ${{ inputs.path != '' }}
      shell: bash
      run: |
        echo "::debug::Validating path input: ${{ steps.normalize-path.outputs.exists }}"

        if [ "${{ steps.normalize-path.outputs.exists }}" != "true" ]; then
          echo "::error file=${{ steps.normalize-path.outputs.exists }}::Specified path does not exist: ${{ steps.normalize-path.outputs.exists }}"
          exit 1
        fi

        echo "✅ Path validation completed successfully"

    - name: "✅ Validate input : booleans"
      shell: bash
      run: |
        echo "::debug::Validating boolean inputs..."
        for param in nologo no-restore no-build; do
          case $param in
            nologo) value="${{ inputs.nologo }}" ;;
            no-restore) value="${{ inputs.no-restore }}" ;;
            no-build) value="${{ inputs.no-build }}" ;;
          esac
          if [ -n "$value" ] && [ "$value" != "true" ] && [ "$value" != "false" ]; then
            echo "::error::Parameter $param must be 'true' or 'false', got: $value"
            exit 1
          fi
        done

        echo "✅ Boolean inputs validation completed successfully"

    - name: "✅ Validate input : command"
      shell: bash
      run: |
        echo "::debug::Validating command input: ${{ inputs.command }}"

        if [ -z "${{ inputs.command }}" ]; then
          echo "::error::Command input is required"
          exit 1
        fi

        echo "✅ Command validation completed successfully"

    - name: "✅ Validate input : verbosity"
      if: ${{ inputs.verbosity != '' }}
      shell: bash
      run: |
        echo "::debug::Validating verbosity input: ${{ inputs.verbosity }}"

        case "${{ inputs.verbosity }}" in
          quiet|minimal|normal|detailed|diagnostic) ;;
          *) echo "::error::Invalid verbosity level: ${{ inputs.verbosity }}. Must be one of: quiet, minimal, normal, detailed, diagnostic"; exit 1 ;;
        esac

        echo "✅ Verbosity validation completed successfully"

    - name: "✅ Validate input : configuration"
      if: ${{ inputs.configuration != '' }}
      shell: bash
      run: |
        echo "::debug::Validating configuration input: ${{ inputs.configuration }}"

        case "${{ inputs.configuration }}" in
          Debug|Release|MinSizeRel|RelWithDebInfo) ;;
          *) echo "::warning::Unusual configuration value: ${{ inputs.configuration }}" ;;
        esac

        echo "✅ Configuration validation completed successfully"

    - name: "✅ Validate input : framework"
      if: ${{ inputs.framework != '' }}
      shell: bash
      run: |
        echo "::debug::Validating framework input: ${{ inputs.framework }}"

        if ! [[ "${{ inputs.framework }}" =~ ^(net[0-9]+\.[0-9]+|netstandard[0-9]+\.[0-9]+|netcoreapp[0-9]+\.[0-9]+|netframework[0-9]+\.[0-9]+)$ ]]; then
          echo "::warning::Framework format may be invalid: ${{ inputs.framework }}"
        fi

        echo "✅ Framework validation completed successfully"

    - name: "✅ Validate input : runtime"
      if: ${{ inputs.runtime != '' }}
      shell: bash
      run: |
        echo "::debug::Validating runtime input: ${{ inputs.runtime }}"

        if ! [[ "${{ inputs.runtime }}" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]; then
          echo "::warning::Runtime identifier format may be invalid: ${{ inputs.runtime }}"
        fi

        echo "✅ Runtime validation completed successfully"

    - name: "✅ Validate input : arch"
      if: ${{ inputs.arch != '' }}
      shell: bash
      run: |
        echo "::debug::Validating arch input: ${{ inputs.arch }}"

        if ! [[ "${{ inputs.arch }}" =~ ^(x86|x64|arm|arm64)$ ]]; then
          echo "::warning::Arch format may be invalid: ${{ inputs.arch }}"
        fi

        echo "✅ Arch validation completed successfully"

    # ================== 🏗️ ==================

    - name: "🔧 Set verbosity level"
      id: validate-verbosity
      shell: bash
      run: |
        if [ -n "${{ inputs.verbosity }}" ]; then
          echo "verbosity=${{ inputs.verbosity }}" >> $GITHUB_OUTPUT
        elif [ "$RUNNER_DEBUG" == "true" ] || [ "$ACTIONS_STEP_DEBUG" == "true" ]; then
          echo "verbosity=diagnostic" >> $GITHUB_OUTPUT
        else
          echo "verbosity=minimal" >> $GITHUB_OUTPUT
        fi

    - name: "🏗️ Build argument list"
      id: build-args
      shell: bash
      run: |
        echo "::debug::Building argument list..."

        # Define command support maps (cached for performance)
        declare -A COMMAND_SUPPORT=(
          ["verbosity"]="build|restore|pack|publish|test|clean|msbuild|workload"
          ["configuration"]="build|publish|test|pack|run"
          ["framework"]="build|publish|test|pack|run"
          ["runtime"]="build|publish|test|pack|run"
          ["arch"]="build|publish|run"
          ["output"]="build|publish|pack|run|tool"
          ["nologo"]="build|restore|pack|publish|test|clean|msbuild|run|add|remove|list"
          ["no-restore"]="build|test|publish|pack"
          ["no-build"]="test|publish"
          ["artifacts-path"]="build|restore|publish|pack|test|clean|run"
        )

        # Function to check command support
        supports_option() {
          local option="$1"
          local command="${{ inputs.command }}"
          echo "$command" | grep -iqE "^(${COMMAND_SUPPORT[$option]})$"
        }

        # Start building arguments
        ARGUMENTS="${{ inputs.command }}"

        if [ -n "${{ inputs.path }}" ]; then
          ARGUMENTS="$ARGUMENTS ${{ steps.normalize-path.outputs.normalized }}"
        fi

        # Add normalized arguments
        if [ -n "${{ steps.normalize-arguments.outputs.normalized }}" ]; then
          NORMALIZED_ARGS="${{ steps.normalize-arguments.outputs.normalized }}"
          echo "::debug::Original arguments: ${{ inputs.arguments }}"
          echo "::debug::Normalized arguments: $NORMALIZED_ARGS"
          ARGUMENTS="$ARGUMENTS $NORMALIZED_ARGS"
        fi

        # Boolean flags
        for param in nologo no-restore no-build; do
          case $param in
            nologo) value="${{ inputs.nologo }}" ;;
            no-restore) value="${{ inputs.no-restore }}" ;;
            no-build) value="${{ inputs.no-build }}" ;;
          esac
          if [ "$value" = "true" ] && supports_option "$param"; then
            ARGUMENTS="$ARGUMENTS --${param}"
          fi
        done

        # Key-value options
        for param in verbosity configuration framework runtime output arch artifacts-path; do
          case $param in
            verbosity) value="${{ steps.validate-verbosity.outputs.verbosity }}" ;;
            configuration) value="${{ inputs.configuration }}" ;;
            framework) value="${{ inputs.framework }}" ;;
            runtime) value="${{ inputs.runtime }}" ;;
            output) value="${{ steps.normalize-output.outputs.normalized }}" ;;
            arch) value="${{ inputs.arch }}" ;;
            artifacts-path) value="${{ steps.normalize-artifacts-path.outputs.normalized }}" ;;
          esac
          if [ -n "$value" ] && supports_option "$param"; then
            ARGUMENTS="$ARGUMENTS --$param '$value'"
          fi
        done

        # Trim leading space
        ARGUMENTS="${ARGUMENTS# }"

        # Store in environment for the next step
        echo "arguments=$ARGUMENTS" >> $GITHUB_OUTPUT

        echo "✅ Argument list built successfully: $ARGUMENTS"

    # ================== 🚀 ==================

    - name: "🚀 Run dotnet command with auto-verbosity"
      id: run-command
      shell: bash
      working-directory: ${{ steps.normalize-working-directory.outputs.normalized }}
      run: |
        echo "::debug::Building final command from environment: ${{ steps.build-args.outputs.arguments }}"

        # Build the full command string
        FULL_COMMAND="dotnet ${{ steps.build-args.outputs.arguments }}"
        echo "::debug::Final command: $FULL_COMMAND"

        # Execute the command using eval for proper argument handling
        echo "✅ Executing: $FULL_COMMAND"
        eval "$FULL_COMMAND"
        EXIT_CODE=$?

        # Enhanced status reporting
        if [ $EXIT_CODE -eq 0 ]; then
          echo "✅ Command completed successfully with exit code 0"
        else
          echo "::error::Command failed with exit code $EXIT_CODE"
        fi

        # Set outputs
        echo "exit-code=$EXIT_CODE" >> $GITHUB_OUTPUT
        echo "executed-command=$FULL_COMMAND" >> $GITHUB_OUTPUT

        # Exit with the same code as the dotnet command
        exit $EXIT_CODE

    # ================== 🔍 ==================

    - name: "🔍 Verify command execution"
      if: always()
      shell: bash
      run: |
        echo "::debug::Verifying command execution results..."

        # Check if the command executed (has exit code output)
        if [ -z "${{ steps.run-command.outputs.exit-code }}" ]; then
          echo "::error::Command execution failed - no exit code available"
          exit 1
        fi

        # Report final status
        EXIT_CODE="${{ steps.run-command.outputs.exit-code }}"
        if [ "$EXIT_CODE" = "0" ]; then
          echo "::debug::✅ .NET command '${{ inputs.command }}' completed successfully"
        else
          echo "::error::❌ .NET command '${{ inputs.command }}' failed with exit code $EXIT_CODE"
        fi

        echo "✅ Command execution verification completed"

    # ================== 📊 ==================

    - name: "📊 Action Summary"
      if: always() && inputs.show-summary == 'true'
      shell: bash
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        <details><summary>⚙️ .NET command : ${{ inputs.command }}</summary>

        ## 🔧 Input Parameters
        | Parameter | Value |
        |-----------|-------|
        | 🚀 Command | `${{ inputs.command }}` |
        | 📍 Path | `${{ steps.normalize-path.outputs.normalized || 'none' }}` |
        | 📁 Working Directory | `${{ steps.normalize-working-directory.outputs.normalized }}` |
        | ⚙️ Configuration | `${{ inputs.configuration }}` |
        | 🎯 Framework | `${{ inputs.framework || 'none' }}` |
        | 🖥️ Runtime | `${{ inputs.runtime || 'none' }}` |
        | 🔧 Arguments | `${{ steps.normalize-arguments.outputs.normalized || 'none' }}` |
        | 🔇 No Logo | `${{ inputs.nologo }}` |
        | 🚫 No Restore | `${{ inputs.no-restore }}` |
        | 🚫 No Build | `${{ inputs.no-build }}` |
        | 📤 Output Path | `${{ steps.normalize-output.outputs.normalized || 'none' }}` |
        | 🗂️ Artifacts Path | `${{ steps.normalize-artifacts-path.outputs.normalized || 'none' }}` |
        | 🔊 Force Verbosity | `${{ inputs.verbosity || 'auto' }}` |

        ## ⚙️ Process Details
        | Step | Status |
        |------|--------|
        | ✅ Input Validation | `✅ Completed` |
        | 🚀 Command Construction | `${{ steps.build-args.outcome == 'success' && '✅ Completed' || '❌ Failed' }}` |
        | 🔧 Compiled Arguments | `${{ steps.build-args.outputs.arguments }}` |
        | 🚀 Command Execution | `${{ steps.run-command.outcome == 'success' && '✅ Completed' || '❌ Failed' }}` |

        ## 📤 Execution Results
        | Metric | Value |
        |--------|-------|
        | ✅ Exit Code | `${{ steps.run-command.outputs.exit-code }}` |
        | 📊 Status | `${{ steps.run-command.outcome }}` |
        | 🚀 Executed Command | `${{ steps.run-command.outputs.executed-command }}` |

        </details>
        EOF

branding:
  icon: "terminal"
  color: "blue"

# dotnet --help
# Usage: dotnet [runtime-options] [path-to-application] [arguments]

# Execute a .NET application.

# runtime-options:
#   --additionalprobingpath <path>   Path containing probing policy and assemblies to probe for.
#   --additional-deps <path>         Path to additional deps.json file.
#   --depsfile                       Path to <application>.deps.json file.
#   --fx-version <version>           Version of the installed Shared Framework to use to run the application.
#   --roll-forward <setting>         Roll forward to framework version  (LatestPatch, Minor, LatestMinor, Major, LatestMajor, Disable).
#   --runtimeconfig                  Path to <application>.runtimeconfig.json file.

# path-to-application:
#   The path to an application .dll file to execute.

# Usage: dotnet [sdk-options] [command] [command-options] [arguments]

# Execute a .NET SDK command.

# sdk-options:
#   -d|--diagnostics  Enable diagnostic output.
#   -h|--help         Show command line help.
#   --info            Display .NET information.
#   --list-runtimes   Display the installed runtimes.
#   --list-sdks       Display the installed SDKs.
#   --version         Display .NET SDK version in use.

# SDK commands:
#   build             Build a .NET project.
#   build-server      Interact with servers started by a build.
#   clean             Clean build outputs of a .NET project.
#   format            Apply style preferences to a project or solution.
#   help              Opens the reference page in a browser for the specified command.
#   msbuild           Run Microsoft Build Engine (MSBuild) commands.
#   new               Create a new .NET project or file.
#   nuget             Provides additional NuGet commands.
#   pack              Create a NuGet package.
#   package           Search for, add, remove, or list PackageReferences for a .NET project.
#   publish           Publish a .NET project for deployment.
#   reference         Add, remove, or list ProjectReferences for a .NET project.
#   restore           Restore dependencies specified in a .NET project.
#   run               Build and run a .NET project output.
#   sdk               Manage .NET SDK installation.
#   solution          Modify Visual Studio solution files.
#   store             Store the specified assemblies in the runtime package store.
#   test              Run unit tests using the test runner specified in a .NET project.
#   tool              Install or manage tools that extend the .NET experience.
#   vstest            Run Microsoft Test Engine (VSTest) commands.
#   workload          Manage optional workloads.

# Additional commands from bundled tools:
#   dev-certs         Create and manage development certificates.
#   fsi               Start F# Interactive / execute F# scripts.
#   user-jwts         Manage JSON Web Tokens in development.
#   user-secrets      Manage development user secrets.
#   watch             Start a file watcher that runs a command when files change.

# Run 'dotnet [command] --help' for more information on a command.
